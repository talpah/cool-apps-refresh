#!/usr/bin/env python3
"""Refresh the cool-apps cheat sheet using an AI CLI backend.

Reads package manager history + shell history and generates a compact reminder of
interesting tools you've installed but might forget about.

Usage:
    cool-apps-refresh               # regenerate (auto-detects AI backend)
    cool-apps-refresh -r/--refresh  # same
    cool-apps-refresh -p/--print    # print cached version
    cool-apps-refresh --ai claude   # use a specific backend
    cool-apps-refresh --ai llm
    cool-apps-refresh --ai sgpt
    cool-apps-refresh --ai aichat
    cool-apps-refresh --ai custom   # uses AI_CMD from ~/.config/cool-apps/config

Config: ~/.config/cool-apps/config
    AI=auto          # auto-detect (default)
    AI=claude        # force a specific backend
    AI=custom
    AI_CMD=ollama run llama3   # used when AI=custom
"""

import gzip
import re
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path

CACHE_FILE = Path.home() / ".cache" / "cool-apps-motd.txt"
EXCLUDE_FILE = Path.home() / ".config" / "cool-apps" / "exclude"
AI_CONFIG_FILE = Path.home() / ".config" / "cool-apps" / "config"

SYSTEM_PROMPT = "You are a helpful assistant. Output plain terminal text only."

# Known backends: tried in this order when AI=auto
AUTO_ORDER = ["claude", "llm", "sgpt", "aichat"]


def _find_bin(name: str) -> str | None:
    """Return full path to binary, checking ~/.local/bin first."""
    local = Path.home() / ".local" / "bin" / name
    if local.exists():
        return str(local)
    return shutil.which(name)


def _build_cmd(backend: str, bin_path: str) -> tuple[list[str], dict]:
    """Return (cmd_args, env_overrides) for the given backend."""
    if backend == "claude":
        return (
            [bin_path, "-p", "--tools", "", "--no-session-persistence",
             "--model", "haiku", "--system-prompt", SYSTEM_PROMPT],
            {"CLAUDECODE": None},   # None = unset the var
        )
    if backend == "llm":
        return ([bin_path, "-s", SYSTEM_PROMPT], {})
    if backend == "sgpt":
        return ([bin_path], {})
    if backend == "aichat":
        return ([bin_path, "-S", SYSTEM_PROMPT], {})
    raise ValueError(f"Unknown backend: {backend}")


def _run_cmd(cmd: list[str]) -> str | None:
    """Run a command silently, return stdout or None on failure/missing binary."""
    try:
        r = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
        return r.stdout if r.returncode == 0 else None
    except (FileNotFoundError, subprocess.TimeoutExpired):
        return None


def load_ai_config() -> dict[str, str]:
    """Read key=value pairs from ~/.config/cool-apps/config."""
    cfg: dict[str, str] = {}
    if not AI_CONFIG_FILE.exists():
        return cfg
    for line in AI_CONFIG_FILE.read_text().splitlines():
        line = line.strip()
        if line and not line.startswith("#") and "=" in line:
            k, v = line.split("=", 1)
            cfg[k.strip()] = v.strip()
    return cfg


def load_exclusions() -> frozenset[str]:
    """Load user exclusion list from ~/.config/cool-apps/exclude."""
    if not EXCLUDE_FILE.exists():
        return frozenset()
    names = set()
    for line in EXCLUDE_FILE.read_text().splitlines():
        line = line.strip()
        if line and not line.startswith("#"):
            names.add(line)
    return frozenset(names)

# Prefixes that are almost never interesting terminal tools
SKIP_PREFIXES = (
    "lib", "python3-", "linux-", "firmware-", "fonts-", "locales",
    "xfonts-", "kde-", "gnome-", "gir1.", "libgl", "libvulkan",
    "libpython", "libnss", "libcurl", "libssl", "libglib",
    "libgtk", "libqt", "libx11", "libxcb", "libxkb", "libwx",
    "libavcodec", "libavformat", "libavutil", "libavdevice",
    "steam-libs", "libmagick",
)

SKIP_PACKAGES = frozenset({
    "locales", "initramfs-tools", "initramfs-tools-core",
    "initramfs-tools-bin", "pciutils", "pci.ids", "busybox",
    "zstd", "bubblewrap", "apparmor", "dracut-install",
    "linux-base", "linux-image-amd64",
})


def _pkg_entry(pkg: str, date: str, exclusions: frozenset[str]) -> dict | None:
    """Return a package entry dict if the package passes all filters, else None."""
    if not pkg or pkg in exclusions or any(pkg.lower().startswith(p) for p in SKIP_PREFIXES):
        return None
    return {"package": pkg, "date": date}


def _parse_apt_block(block: str) -> list[dict]:
    """Extract manually-installed packages from one apt history block."""
    if "Install:" not in block:
        return []

    lines: dict[str, str] = {}
    for line in block.splitlines():
        if ": " in line:
            k, v = line.split(": ", 1)
            lines[k.strip()] = v.strip()

    install_line = lines.get("Install", "")
    date = lines.get("Start-Date", "")[:10]

    results = []
    for entry in install_line.split("),"):
        entry = entry.strip().rstrip(")")
        if not entry or "automatic" in entry:
            continue
        match = re.match(r"^(\S+?)(?::\w+)?\s*\(", entry)
        if not match:
            continue
        pkg = match.group(1)
        if pkg in SKIP_PACKAGES:
            continue
        if any(pkg.lower().startswith(p) for p in SKIP_PREFIXES):
            continue
        results.append({"package": pkg, "date": date})

    return results


def parse_apt_history(exclusions: frozenset[str]) -> list[dict]:
    """Return deduped list of manually-installed packages, newest first."""
    texts: list[str] = []

    current = Path("/var/log/apt/history.log")
    if current.exists():
        texts.append(current.read_text(errors="replace"))

    for gz in sorted(Path("/var/log/apt").glob("history.log.*.gz")):
        try:
            with gzip.open(gz, "rt", errors="replace") as f:
                texts.append(f.read())
        except OSError:
            pass

    seen: dict[str, dict] = {}
    for text in texts:
        for block in re.split(r"\n\n+", text.strip()):
            for entry in _parse_apt_block(block):
                pkg = entry["package"]
                if pkg in exclusions:
                    continue
                if pkg not in seen or entry["date"] > seen[pkg]["date"]:
                    seen[pkg] = entry

    return sorted(seen.values(), key=lambda x: x["date"], reverse=True)


def parse_pacman_history(exclusions: frozenset[str]) -> list[dict]:
    """Parse /var/log/pacman.log for installed packages (Arch Linux)."""
    log = Path("/var/log/pacman.log")
    if not log.exists():
        return []
    pat = re.compile(r"^\[(\d{4}-\d{2}-\d{2})T[^\]]+\] \[ALPM\] installed (\S+)")
    seen: dict[str, dict] = {}
    for line in log.read_text(errors="replace").splitlines():
        m = pat.match(line)
        if not m:
            continue
        e = _pkg_entry(m.group(2), m.group(1), exclusions)
        if e:
            pkg = e["package"]
            if pkg not in seen or e["date"] > seen[pkg]["date"]:
                seen[pkg] = e
    return list(seen.values())


def parse_dnf_history(exclusions: frozenset[str]) -> list[dict]:
    """Parse dnf/yum log for installed packages (Fedora/RHEL/CentOS)."""
    for path in ["/var/log/dnf.rpm.log", "/var/log/yum.log"]:
        log = Path(path)
        if log.exists():
            break
    else:
        return []
    # Lines like: "2024-01-15T10:30:00Z SUBDEBUG Installed: vim-enhanced-9.0-1.fc38.x86_64"
    pat = re.compile(r"^(\d{4}-\d{2}-\d{2})T.+Installed:\s+(\S+)")
    seen: dict[str, dict] = {}
    for line in log.read_text(errors="replace").splitlines():
        m = pat.match(line)
        if not m:
            continue
        date, raw = m.group(1), m.group(2)
        # RPM NEVRA: name-version-release.arch — name never starts with a digit
        name_m = re.match(r"^(.+?)-\d", raw) or re.match(r"^(.+?)\.", raw)
        pkg = name_m.group(1) if name_m else raw
        e = _pkg_entry(pkg, date, exclusions)
        if e and (pkg not in seen or date > seen[pkg]["date"]):
            seen[pkg] = e
    return list(seen.values())


def parse_zypper_history(exclusions: frozenset[str]) -> list[dict]:
    """Parse /var/log/zypp/history for installed packages (openSUSE)."""
    log = Path("/var/log/zypp/history")
    if not log.exists():
        return []
    # Pipe-delimited CSV: date|install|name|version|arch|...
    seen: dict[str, dict] = {}
    for line in log.read_text(errors="replace").splitlines():
        if line.startswith("#"):
            continue
        parts = line.split("|")
        if len(parts) < 3 or parts[1].strip() != "install":
            continue
        date, pkg = parts[0].strip()[:10], parts[2].strip()
        e = _pkg_entry(pkg, date, exclusions)
        if e and (pkg not in seen or date > seen[pkg]["date"]):
            seen[pkg] = e
    return list(seen.values())


def parse_snap_packages(exclusions: frozenset[str]) -> list[dict]:
    """List installed snap packages (cross-distro)."""
    out = _run_cmd(["snap", "list", "--unicode=never"])
    if not out:
        return []
    results = []
    for line in out.splitlines()[1:]:  # skip header row
        parts = line.split()
        e = _pkg_entry(parts[0], "", exclusions) if parts else None
        if e:
            results.append(e)
    return results


def parse_flatpak_packages(exclusions: frozenset[str]) -> list[dict]:
    """List installed flatpak apps (cross-distro). Uses last component of app ID."""
    out = _run_cmd(["flatpak", "list", "--app", "--columns=application"])
    if not out:
        return []
    results = []
    for line in out.splitlines():
        line = line.strip()
        pkg = line.split(".")[-1] if "." in line else line
        e = _pkg_entry(pkg, "", exclusions) if pkg else None
        if e:
            results.append(e)
    return results


def parse_brew_packages(exclusions: frozenset[str]) -> list[dict]:
    """List Homebrew formula packages (macOS / Linux)."""
    out = _run_cmd(["brew", "list", "--formula", "-1"])
    if not out:
        return []
    return [e for line in out.splitlines() if (e := _pkg_entry(line.strip(), "", exclusions))]


def collect_packages(exclusions: frozenset[str]) -> list[dict]:
    """Gather installed packages from all detected package managers, deduped, newest first."""
    all_entries: list[dict] = []
    for parser in [
        parse_apt_history,
        parse_pacman_history,
        parse_dnf_history,
        parse_zypper_history,
        parse_snap_packages,
        parse_flatpak_packages,
        parse_brew_packages,
    ]:
        all_entries.extend(parser(exclusions))
    seen: dict[str, dict] = {}
    for e in all_entries:
        pkg = e["package"]
        if pkg not in seen or e["date"] > seen[pkg]["date"]:
            seen[pkg] = e
    return sorted(seen.values(), key=lambda x: x["date"], reverse=True)


def parse_shell_history(tail: int = 400) -> list[str]:
    """Return the last N commands from whichever shell history files are present."""
    commands: list[str] = []

    # zsh: extended format `: timestamp:elapsed;command`, or plain lines
    zsh_hist = Path.home() / ".zsh_history"
    if zsh_hist.exists():
        for line in zsh_hist.read_text(errors="replace").splitlines():
            if line.startswith(": "):
                m = re.match(r"^: \d+:\d+;(.+)$", line)
                if m:
                    commands.append(m.group(1).strip())
            elif line.strip() and not line.startswith("#"):
                commands.append(line.strip())

    # bash / ksh: plain text; lines starting with # are timestamps, skip them
    for hist_path in ("~/.bash_history", "~/.sh_history", "~/.ksh_history"):
        hist = Path(hist_path).expanduser()
        if hist.exists():
            for line in hist.read_text(errors="replace").splitlines():
                line = line.strip()
                if line and not line.startswith("#"):
                    commands.append(line)

    # fish: `- cmd: command` / `  when: timestamp` YAML-ish pairs
    fish_hist = Path.home() / ".local" / "share" / "fish" / "fish_history"
    if fish_hist.exists():
        for line in fish_hist.read_text(errors="replace").splitlines():
            m = re.match(r"^- cmd:\s+(.+)$", line)
            if m:
                commands.append(m.group(1).strip())

    return commands[-tail:]


def unique_binaries(commands: list[str], exclusions: frozenset[str]) -> list[str]:
    """Extract sorted unique binary names from a list of shell commands."""
    names: set[str] = set()
    for cmd in commands:
        for part in re.split(r"[|;&(]", cmd):
            part = part.strip()
            if not part:
                continue
            tokens = [t for t in part.split() if "=" not in t]
            if not tokens:
                continue
            binary = tokens[0].split("/")[-1].lstrip("$")
            if binary and not binary.startswith("-") and binary.isidentifier():
                if binary not in exclusions:
                    names.add(binary)
    return sorted(names)


def build_prompt(packages: list[dict], binaries: list[str], recent: list[str],
                 max_lines: int = 45) -> str:
    pkg_text = "\n".join(f"  {p['date']}  {p['package']}" for p in packages[:100])
    bin_text = ", ".join(binaries[:120])
    recent_text = "\n".join(f"  {c}" for c in recent[-60:])

    return f"""I need a reminder cheat sheet of cool terminal tools I've installed but might forget.

INSTALLED PACKAGES (newest first, across all package managers):
{pkg_text}

UNIQUE BINARIES FROM MY RECENT SHELL HISTORY:
{bin_text}

RECENT SHELL HISTORY SAMPLE (last 60 commands):
{recent_text}

Generate a compact cheat sheet. Requirements:
- Skip obvious daily-driver tools (git, vim, python, ssh, curl, grep, docker, ls, cat, etc.)
- For each tool: name + one-sentence description + ONE killer example command
- If the tool hasn't been used recently, prefix the example command with ⚡ (no other annotation)
- Group into 3-5 categories with ASCII dividers
- Max {max_lines} lines total, no markdown, terminal-friendly plain text
- No title, no surrounding box — just the category sections

Example format (note: non-⚡ lines use 3 spaces to align with "⚡ "):
  ── MEDIA ──────────────────────────────────────────
    ffmpeg     Convert/encode video          ffmpeg -i in.mp4 -c:v h264 out.mkv
    chafa      Image → ANSI art           ⚡ chafa --colors 256 photo.jpg

  ── NETWORK ────────────────────────────────────────
    socat      Multipurpose TCP relay     ⚡ socat TCP-LISTEN:8080,fork TCP:localhost:3000
    xxd        Hex dumper                    xxd file.bin | head -20
"""


def call_ai(prompt: str, backend: str = "auto", custom_cmd: str = "") -> str:
    """Invoke an AI CLI with the prompt via stdin, return the response."""
    import os

    env = os.environ.copy()

    if backend == "auto":
        for name in AUTO_ORDER:
            if _find_bin(name):
                backend = name
                break
        else:
            print(
                f"Error: no AI backend found. Install one of: {', '.join(AUTO_ORDER)}\n"
                f"Or set AI=custom + AI_CMD=... in {AI_CONFIG_FILE}",
                file=sys.stderr,
            )
            sys.exit(1)

    if backend == "custom":
        if not custom_cmd:
            print(f"Error: AI=custom requires AI_CMD in {AI_CONFIG_FILE}", file=sys.stderr)
            sys.exit(1)
        cmd = custom_cmd.split()
        # custom commands get system prompt prepended to stdin
        stdin_text = f"{SYSTEM_PROMPT}\n\n{prompt}"
    else:
        bin_path = _find_bin(backend)
        if not bin_path:
            print(f"Error: backend '{backend}' not found in PATH", file=sys.stderr)
            sys.exit(1)
        cmd, env_overrides = _build_cmd(backend, bin_path)
        for k, v in env_overrides.items():
            if v is None:
                env.pop(k, None)
            else:
                env[k] = v
        # sgpt doesn't have a system-prompt flag — prepend to stdin
        stdin_text = f"{SYSTEM_PROMPT}\n\n{prompt}" if backend == "sgpt" else prompt

    print(f"→ Calling {backend} ...", file=sys.stderr)
    proc = subprocess.Popen(
        cmd,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        env=env,
    )
    stdout, stderr = proc.communicate(input=stdin_text, timeout=120)

    if proc.returncode != 0:
        print(f"Error: {backend} exited {proc.returncode}", file=sys.stderr)
        if stderr:
            print(stderr, file=sys.stderr)
        sys.exit(1)

    return stdout.strip()


def fix_alignment(text: str) -> str:
    """Re-align tool entry lines to consistent name/description/command columns.

    Uses two patterns:
    - ⚡ lines : split on the ⚡ character — reliable regardless of spacing
    - plain lines: split on 2+ consecutive spaces between description and command
    ⚡ is assumed to occupy 2 terminal columns, so non-⚡ uses 3 spaces to align.
    """
    # ⚡ lines: capture everything before ⚡ as name+desc, rest as cmd
    bolt_pat  = re.compile(r"^( {2,4})(\S+)\s+(.+?)\s*⚡\s*(.+)$")
    # plain lines: desc and cmd separated by 2+ spaces
    plain_pat = re.compile(r"^( {2,4})(\S+)\s{2,}(.+?)\s{2,}(.+)$")

    parsed = []
    for line in text.splitlines():
        m = bolt_pat.match(line)
        if m:
            indent, name, desc, cmd = m.groups()
            parsed.append((True, indent, name, desc.strip(), True, cmd.strip()))
            continue
        m = plain_pat.match(line)
        if m:
            indent, name, desc, cmd = m.groups()
            parsed.append((True, indent, name, desc.strip(), False, cmd.strip()))
            continue
        parsed.append((False, line))

    tool_rows = [p for p in parsed if p[0]]
    if not tool_rows:
        return text

    name_w = max(len(p[2]) for p in tool_rows)
    desc_w = min(max(len(p[3]) for p in tool_rows), 34)

    out = []
    for p in parsed:
        if not p[0]:
            out.append(p[1])
        else:
            _, indent, name, desc, has_bolt, cmd = p
            # ⚡ renders as 2 terminal columns; 3 spaces matches its visual width
            prefix = "⚡ " if has_bolt else "   "
            out.append(f"{indent}{name:<{name_w}}  {desc:<{desc_w}}  {prefix}{cmd}")

    return "\n".join(out)


def main() -> None:
    argv = sys.argv[1:]

    if "--print" in argv or "-p" in argv:
        if CACHE_FILE.exists():
            print(CACHE_FILE.read_text())
        else:
            print("No cached cheat sheet yet. Run: cool-apps-refresh", file=sys.stderr)
        return

    # --ai <backend> overrides config
    ai_cfg = load_ai_config()
    backend = ai_cfg.get("AI", "auto")
    custom_cmd = ai_cfg.get("AI_CMD", "")
    try:
        max_lines = int(ai_cfg.get("MAX_LINES", "45"))
    except ValueError:
        max_lines = 45
    if "--ai" in argv:
        idx = argv.index("--ai")
        if idx + 1 < len(argv):
            backend = argv[idx + 1]

    exclusions = load_exclusions()

    print("→ Parsing package manager history...", file=sys.stderr)
    packages = collect_packages(exclusions)

    print("→ Parsing shell history...", file=sys.stderr)
    history = parse_shell_history()
    binaries = unique_binaries(history, exclusions)

    print(
        f"→ Found {len(packages)} packages, {len(binaries)} unique binaries",
        file=sys.stderr,
    )

    prompt = build_prompt(packages, binaries, history, max_lines=max_lines)

    body = call_ai(prompt, backend=backend, custom_cmd=custom_cmd)
    # Strip markdown code fences Claude sometimes wraps output in
    body = re.sub(r"^```[a-z]*\n?", "", body, flags=re.MULTILINE)
    body = re.sub(r"^```$", "", body, flags=re.MULTILINE)
    body = fix_alignment(body.strip())

    now = datetime.now().strftime("%Y-%m-%d %H:%M")
    output = f"\n{body}\n\n  ↻ updated {now} · run cool-apps-refresh to regenerate\n"

    CACHE_FILE.parent.mkdir(parents=True, exist_ok=True)
    CACHE_FILE.write_text(output)

    print(f"→ Written to {CACHE_FILE}", file=sys.stderr)
    print(output)


if __name__ == "__main__":
    main()
