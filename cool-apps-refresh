#!/usr/bin/env python3
"""Refresh the cool-apps cheat sheet using an AI CLI backend.

Reads apt history + zsh history and generates a compact reminder of
interesting tools you've installed but might forget about.

Usage:
    cool-apps-refresh               # regenerate (auto-detects AI backend)
    cool-apps-refresh -r/--refresh  # same
    cool-apps-refresh -p/--print    # print cached version
    cool-apps-refresh --ai claude   # use a specific backend
    cool-apps-refresh --ai llm
    cool-apps-refresh --ai sgpt
    cool-apps-refresh --ai aichat
    cool-apps-refresh --ai custom   # uses AI_CMD from ~/.config/cool-apps/config

Config: ~/.config/cool-apps/config
    AI=auto          # auto-detect (default)
    AI=claude        # force a specific backend
    AI=custom
    AI_CMD=ollama run llama3   # used when AI=custom
"""

import gzip
import re
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path

CACHE_FILE = Path.home() / ".cache" / "cool-apps-motd.txt"
EXCLUDE_FILE = Path.home() / ".config" / "cool-apps" / "exclude"
AI_CONFIG_FILE = Path.home() / ".config" / "cool-apps" / "config"

SYSTEM_PROMPT = "You are a helpful assistant. Output plain terminal text only."

# Known backends: tried in this order when AI=auto
AUTO_ORDER = ["claude", "llm", "sgpt", "aichat"]


def _find_bin(name: str) -> str | None:
    """Return full path to binary, checking ~/.local/bin first."""
    local = Path.home() / ".local" / "bin" / name
    if local.exists():
        return str(local)
    return shutil.which(name)


def _build_cmd(backend: str, bin_path: str) -> tuple[list[str], dict]:
    """Return (cmd_args, env_overrides) for the given backend."""
    if backend == "claude":
        return (
            [bin_path, "-p", "--tools", "", "--no-session-persistence",
             "--model", "haiku", "--system-prompt", SYSTEM_PROMPT],
            {"CLAUDECODE": None},   # None = unset the var
        )
    if backend == "llm":
        return ([bin_path, "-s", SYSTEM_PROMPT], {})
    if backend == "sgpt":
        return ([bin_path], {})
    if backend == "aichat":
        return ([bin_path, "-S", SYSTEM_PROMPT], {})
    raise ValueError(f"Unknown backend: {backend}")


def load_ai_config() -> dict[str, str]:
    """Read key=value pairs from ~/.config/cool-apps/config."""
    cfg: dict[str, str] = {}
    if not AI_CONFIG_FILE.exists():
        return cfg
    for line in AI_CONFIG_FILE.read_text().splitlines():
        line = line.strip()
        if line and not line.startswith("#") and "=" in line:
            k, v = line.split("=", 1)
            cfg[k.strip()] = v.strip()
    return cfg


def load_exclusions() -> frozenset[str]:
    """Load user exclusion list from ~/.config/cool-apps/exclude."""
    if not EXCLUDE_FILE.exists():
        return frozenset()
    names = set()
    for line in EXCLUDE_FILE.read_text().splitlines():
        line = line.strip()
        if line and not line.startswith("#"):
            names.add(line)
    return frozenset(names)

# Prefixes that are almost never interesting terminal tools
SKIP_PREFIXES = (
    "lib", "python3-", "linux-", "firmware-", "fonts-", "locales",
    "xfonts-", "kde-", "gnome-", "gir1.", "libgl", "libvulkan",
    "libpython", "libnss", "libcurl", "libssl", "libglib",
    "libgtk", "libqt", "libx11", "libxcb", "libxkb", "libwx",
    "libavcodec", "libavformat", "libavutil", "libavdevice",
    "steam-libs", "libmagick",
)

SKIP_PACKAGES = frozenset({
    "locales", "initramfs-tools", "initramfs-tools-core",
    "initramfs-tools-bin", "pciutils", "pci.ids", "busybox",
    "zstd", "bubblewrap", "apparmor", "dracut-install",
    "linux-base", "linux-image-amd64",
})


def _parse_apt_block(block: str) -> list[dict]:
    """Extract manually-installed packages from one apt history block."""
    if "Install:" not in block:
        return []

    lines: dict[str, str] = {}
    for line in block.splitlines():
        if ": " in line:
            k, v = line.split(": ", 1)
            lines[k.strip()] = v.strip()

    install_line = lines.get("Install", "")
    date = lines.get("Start-Date", "")[:10]

    results = []
    for entry in install_line.split("),"):
        entry = entry.strip().rstrip(")")
        if not entry or "automatic" in entry:
            continue
        match = re.match(r"^(\S+?)(?::\w+)?\s*\(", entry)
        if not match:
            continue
        pkg = match.group(1)
        if pkg in SKIP_PACKAGES:
            continue
        if any(pkg.lower().startswith(p) for p in SKIP_PREFIXES):
            continue
        results.append({"package": pkg, "date": date})

    return results


def parse_apt_history(exclusions: frozenset[str]) -> list[dict]:
    """Return deduped list of manually-installed packages, newest first."""
    texts: list[str] = []

    current = Path("/var/log/apt/history.log")
    if current.exists():
        texts.append(current.read_text(errors="replace"))

    for gz in sorted(Path("/var/log/apt").glob("history.log.*.gz")):
        try:
            with gzip.open(gz, "rt", errors="replace") as f:
                texts.append(f.read())
        except OSError:
            pass

    seen: dict[str, dict] = {}
    for text in texts:
        for block in re.split(r"\n\n+", text.strip()):
            for entry in _parse_apt_block(block):
                pkg = entry["package"]
                if pkg in exclusions:
                    continue
                if pkg not in seen or entry["date"] > seen[pkg]["date"]:
                    seen[pkg] = entry

    return sorted(seen.values(), key=lambda x: x["date"], reverse=True)


def parse_zsh_history(tail: int = 400) -> list[str]:
    """Return the last N commands from zsh history."""
    hist = Path.home() / ".zsh_history"
    if not hist.exists():
        return []
    lines = hist.read_text(errors="replace").splitlines()
    commands = []
    for line in lines:
        # Extended history format: `: timestamp:elapsed;command`
        if line.startswith(": "):
            m = re.match(r"^: \d+:\d+;(.+)$", line)
            if m:
                commands.append(m.group(1).strip())
        elif line.strip() and not line.startswith("#"):
            commands.append(line.strip())
    return commands[-tail:]


def unique_binaries(commands: list[str], exclusions: frozenset[str]) -> list[str]:
    """Extract sorted unique binary names from a list of shell commands."""
    names: set[str] = set()
    for cmd in commands:
        for part in re.split(r"[|;&(]", cmd):
            part = part.strip()
            if not part:
                continue
            tokens = [t for t in part.split() if "=" not in t]
            if not tokens:
                continue
            binary = tokens[0].split("/")[-1].lstrip("$")
            if binary and not binary.startswith("-") and binary.isidentifier():
                if binary not in exclusions:
                    names.add(binary)
    return sorted(names)


def build_prompt(packages: list[dict], binaries: list[str], recent: list[str]) -> str:
    pkg_text = "\n".join(f"  {p['date']}  {p['package']}" for p in packages[:100])
    bin_text = ", ".join(binaries[:120])
    recent_text = "\n".join(f"  {c}" for c in recent[-60:])

    return f"""I need a reminder cheat sheet of cool terminal tools I've installed but might forget.

MANUALLY INSTALLED PACKAGES (newest first):
{pkg_text}

UNIQUE BINARIES FROM MY RECENT ZSH HISTORY:
{bin_text}

RECENT SHELL HISTORY SAMPLE (last 60 commands):
{recent_text}

Generate a compact cheat sheet. Requirements:
- Skip obvious daily-driver tools (git, vim, python, ssh, curl, grep, docker, ls, cat, etc.)
- For each tool: name + one-sentence description + ONE killer example command
- If the tool hasn't been used recently, prefix the example command with ⚡ (no other annotation)
- Group into 3-5 categories with ASCII dividers
- Max 45 lines total, no markdown, terminal-friendly plain text
- No title, no surrounding box — just the category sections

Example format (note: non-⚡ lines use 3 spaces to align with "⚡ "):
  ── MEDIA ──────────────────────────────────────────
    ffmpeg     Convert/encode video          ffmpeg -i in.mp4 -c:v h264 out.mkv
    chafa      Image → ANSI art           ⚡ chafa --colors 256 photo.jpg

  ── NETWORK ────────────────────────────────────────
    socat      Multipurpose TCP relay     ⚡ socat TCP-LISTEN:8080,fork TCP:localhost:3000
    xxd        Hex dumper                    xxd file.bin | head -20
"""


def call_ai(prompt: str, backend: str = "auto", custom_cmd: str = "") -> str:
    """Invoke an AI CLI with the prompt via stdin, return the response."""
    import os

    env = os.environ.copy()

    if backend == "auto":
        for name in AUTO_ORDER:
            if _find_bin(name):
                backend = name
                break
        else:
            print(
                f"Error: no AI backend found. Install one of: {', '.join(AUTO_ORDER)}\n"
                f"Or set AI=custom + AI_CMD=... in {AI_CONFIG_FILE}",
                file=sys.stderr,
            )
            sys.exit(1)

    if backend == "custom":
        if not custom_cmd:
            print(f"Error: AI=custom requires AI_CMD in {AI_CONFIG_FILE}", file=sys.stderr)
            sys.exit(1)
        cmd = custom_cmd.split()
        # custom commands get system prompt prepended to stdin
        stdin_text = f"{SYSTEM_PROMPT}\n\n{prompt}"
    else:
        bin_path = _find_bin(backend)
        if not bin_path:
            print(f"Error: backend '{backend}' not found in PATH", file=sys.stderr)
            sys.exit(1)
        cmd, env_overrides = _build_cmd(backend, bin_path)
        for k, v in env_overrides.items():
            if v is None:
                env.pop(k, None)
            else:
                env[k] = v
        # sgpt doesn't have a system-prompt flag — prepend to stdin
        stdin_text = f"{SYSTEM_PROMPT}\n\n{prompt}" if backend == "sgpt" else prompt

    print(f"→ Calling {backend} ...", file=sys.stderr)
    proc = subprocess.Popen(
        cmd,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        env=env,
    )
    stdout, stderr = proc.communicate(input=stdin_text, timeout=120)

    if proc.returncode != 0:
        print(f"Error: {backend} exited {proc.returncode}", file=sys.stderr)
        if stderr:
            print(stderr, file=sys.stderr)
        sys.exit(1)

    return stdout.strip()


def fix_alignment(text: str) -> str:
    """Re-align tool entry lines to consistent name/description/command columns.

    Parses lines of the form:
        <indent><name>   <description>   [⚡ ]<command>
    and re-emits them with padded, consistent column widths.
    ⚡ is assumed to occupy 2 terminal columns, so non-⚡ lines use 3 spaces.
    """
    # name is one word; description and command are separated by 2+ spaces.
    # We split on 2+ spaces (max 2 splits) to get [name, desc, cmd_part].
    tool_pat = re.compile(r"^( {2,4})(\S+)\s{2,}(.+?)\s{2,}(⚡\s*)?(.+)$")

    parsed = []
    for line in text.splitlines():
        m = tool_pat.match(line)
        if m:
            indent, name, desc, bolt, cmd = m.groups()
            parsed.append((True, indent, name, desc.strip(), bool(bolt), cmd.strip()))
        else:
            parsed.append((False, line))

    tool_rows = [p for p in parsed if p[0]]
    if not tool_rows:
        return text

    name_w = max(len(p[2]) for p in tool_rows)
    desc_w = min(max(len(p[3]) for p in tool_rows), 34)

    out = []
    for p in parsed:
        if not p[0]:
            out.append(p[1])
        else:
            _, indent, name, desc, has_bolt, cmd = p
            # ⚡ is ~2 terminal columns wide, so non-⚡ uses 3 spaces to match "⚡ "
            prefix = "⚡ " if has_bolt else "   "
            out.append(f"{indent}{name:<{name_w}}  {desc:<{desc_w}}  {prefix}{cmd}")

    return "\n".join(out)


def main() -> None:
    argv = sys.argv[1:]

    if "--print" in argv or "-p" in argv:
        if CACHE_FILE.exists():
            print(CACHE_FILE.read_text())
        else:
            print("No cached cheat sheet yet. Run: cool-apps-refresh", file=sys.stderr)
        return

    # --ai <backend> overrides config
    ai_cfg = load_ai_config()
    backend = ai_cfg.get("AI", "auto")
    custom_cmd = ai_cfg.get("AI_CMD", "")
    if "--ai" in argv:
        idx = argv.index("--ai")
        if idx + 1 < len(argv):
            backend = argv[idx + 1]

    exclusions = load_exclusions()

    print("→ Parsing apt history...", file=sys.stderr)
    packages = parse_apt_history(exclusions)

    print("→ Parsing zsh history...", file=sys.stderr)
    history = parse_zsh_history()
    binaries = unique_binaries(history, exclusions)

    print(
        f"→ Found {len(packages)} packages, {len(binaries)} unique binaries",
        file=sys.stderr,
    )

    prompt = build_prompt(packages, binaries, history)

    body = call_ai(prompt, backend=backend, custom_cmd=custom_cmd)
    # Strip markdown code fences Claude sometimes wraps output in
    body = re.sub(r"^```[a-z]*\n?", "", body, flags=re.MULTILINE)
    body = re.sub(r"^```$", "", body, flags=re.MULTILINE)
    body = fix_alignment(body.strip())

    now = datetime.now().strftime("%Y-%m-%d %H:%M")
    output = f"\n{body}\n\n  ↻ updated {now} · run cool-apps-refresh to regenerate\n"

    CACHE_FILE.parent.mkdir(parents=True, exist_ok=True)
    CACHE_FILE.write_text(output)

    print(f"→ Written to {CACHE_FILE}", file=sys.stderr)
    print(output)


if __name__ == "__main__":
    main()
